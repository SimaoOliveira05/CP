\documentclass[11pt, a4paper, fleqn]{article}
\usepackage{cp2526t}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{array}
\usetikzlibrary{positioning}
\makeindex

%================= lhs2tex=====================================================%
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%%format (bin (n) (k)) = "\Big(\vcenter{\xymatrix@R=1pt{" n "\\" k "}}\Big)"
%------------------------------------------------------------------------------%


%====== DEFINIR GRUPO E ELEMENTOS =============================================%

\group{G31}
\studentA{107291}{Gabriel Pinto Dantas}
\studentB{106937}{José Lourenço Ferreira Fernandes}
\studentC{107322}{Simão Azevedo Oliveira}

%==============================================================================%

\begin{document}
\sffamily
\setlength{\parindent}{0em}
\emergencystretch 3em
\renewcommand{\baselinestretch}{1.25} 
\input{Cover}
\pagestyle{pagestyle}

\newgeometry{left=25mm,right=20mm,top=25mm,bottom=25mm}
\setlength{\parindent}{1em}

\section*{Preâmbulo}

Em \CP\ pretende-se ensinar a progra\-mação de computadores
como uma disciplina científica. Para isso parte-se de um repertório de \emph{combinadores}
que formam uma álgebra da programação % (conjunto de leis universais e seus corolários)
e usam-se esses combinadores para construir programas \emph{composicionalmente},
isto é, agregando programas já existentes.

Na sequência pedagógica dos planos de estudo dos cursos que têm
esta disciplina, opta-se pela aplicação deste método à programação
em \Haskell\ (sem prejuízo da sua aplicação a outras linguagens
funcionais). Assim, o presente trabalho prático coloca os
alunos perante problemas concretos que deverão ser implementados em
\Haskell. Há ainda um outro objectivo: o de ensinar a documentar
programas, a validá-los e a produzir textos técnico-científicos de
qualidade.

Antes de abordarem os problemas propostos no trabalho, os grupos devem ler
com atenção o anexo \ref{sec:documentacao} onde encontrarão as instruções
relativas ao \emph{software} a instalar, etc.

Valoriza-se a escrita de \emph{pouco} código que corresponda a soluções
simples e elegantes que utilizem os combinadores de ordem superior estudados
na disciplina.

\noindent \textbf{Avaliação}. Faz parte da avaliação do trabalho a sua defesa
por parte dos elementos de cada grupo. Estes devem estar preparados para
responder a perguntas sobre \emph{qualquer} dos problemas deste enunciado.
A prestação \emph{individual} de cada aluno nessa defesa oral será uma componente
importante e diferenciadora da avaliação.


\Problema

Uma serialização (ou travessia) de uma árvore é uma sua representação sob a forma de uma lista. 
Na biblioteca \ensuremath{\Conid{BTree}} encontram-se as funções de serialização \ensuremath{\Varid{inordt}}, \ensuremath{\Varid{preordt}} e \ensuremath{\Varid{postordt}},
que fazem as travessias \emph{in-order}, \emph{ pre-order} e \emph{post-order}, respectivamente.
Todas essas travessias são catamorfismos que percorrem a árvore argumento em regime \emph{depth-first}.

Pretende-se agora uma função \ensuremath{\Varid{bforder}} que faça a travessia em regime \emph{breadth-first},
isto é, por níveis.
Por exemplo, para a árvore \ensuremath{t_1 } dada em anexo e mostrada na figura a seguir,

\begin{center}
	\figura
\end{center}

\noindent a função deverá dar a lista

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}[\mskip1.5mu \mathrm{5},\mathrm{3},\mathrm{7},\mathrm{1},\mathrm{4},\mathrm{6},\mathrm{8}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\noindent em que se vê como os níveis \ensuremath{\mathrm{5}}, depois \ensuremath{\mathrm{3},\mathrm{7}} e finalmente \ensuremath{\mathrm{1},\mathrm{4},\mathrm{6},\mathrm{8}} foram percorridos.

Pretendemos propor duas versões dessa função:

\begin{enumerate}
\item	Uma delas envolve um catamorfismo de \ensuremath{\Conid{BTree}}s:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bfsLevels}\mathbin{::}\Conid{BTree}\;\Varid{a}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{bfsLevels}\mathrel{=}\Varid{concat}\comp \Varid{levels}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Complete a definição desse catamorfismo:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{levels}\mathbin{::}\Conid{BTree}\;\Varid{a}\to [\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{levels}\mathrel{=}\llparenthesis\, \Varid{glevels}\,\rrparenthesis{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\item A segunda proposta,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bft}\mathbin{::}\Conid{BTree}\;\Varid{a}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
deverá basear-se num anamorfismo de listas.
\end{enumerate}
\textbf{Sugestão}: estudar o artigo \cite{Ok00} cujo PDF está incluído no material deste trabalho. 
Quando fizer testes ao seu código pode, se desejar, usar funções disponíveis na biblioteca
\ensuremath{\Conid{Exp}} para visualizar as árvores em GraphViz (formato .dot).

Justifique devidamente a sua resolução, que deverá vir acompanhada de diagramas explicativos.
Como já se disse, valoriza-se a escrita de \emph{pouco} código que corresponda a soluções
simples e elegantes que utilizem os combinadores de ordem superior estudados
na disciplina.



\Problema

Considere a seguinte função em Haskell:
\begin{quote}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{46}{@{}>{\hspre}l<{\hspost}@{}}%
\column{52}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f}\;\Varid{x}\mathrel{=}\Varid{wrapper}\comp \Varid{worker}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}\Varid{wrapper}\mathrel{=}\Varid{head}{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}\Varid{worker}\;\mathrm{0}\mathrel{=}\Varid{start}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}\Varid{worker}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{loop}\;\Varid{x}\;(\Varid{worker}\;\Varid{n}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{loop}\;\Varid{x}\;{}\<[11]%
\>[11]{}[\mskip1.5mu \Varid{s},{}\<[23]%
\>[23]{}\Varid{h},{}\<[32]%
\>[32]{}\Varid{k},{}\<[39]%
\>[39]{}\Varid{j},{}\<[46]%
\>[46]{}\Varid{m}{}\<[52]%
\>[52]{}\mskip1.5mu]\mathrel{=}{}\<[E]%
\\
\>[11]{}[\mskip1.5mu \Varid{h}\mathbin{/}\Varid{k}\mathbin{+}\Varid{s},\Varid{x}\mathbin{\uparrow}\mathrm{2}\mathbin{*}\Varid{h},\Varid{k}\mathbin{*}\Varid{j},\Varid{j}\mathbin{+}\Varid{m},\Varid{m}\mathbin{+}\mathrm{8}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{start}\;\Varid{x}\mathrel{=}[\mskip1.5mu \Varid{x},{}\<[23]%
\>[23]{}\Varid{x}\mathbin{\uparrow}\mathrm{3},{}\<[32]%
\>[32]{}\mathrm{6},{}\<[39]%
\>[39]{}\mathrm{20},{}\<[46]%
\>[46]{}\mathrm{22}{}\<[52]%
\>[52]{}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{quote}
Pode-se provar pela lei de recursividade mútua que \ensuremath{\Varid{f}\;\Varid{x}\;\Varid{n}} calcula o seno hiperbólico de \ensuremath{\Varid{x}},
\ensuremath{\Varid{sinh}\;\Varid{x}}, para \ensuremath{\Varid{n}} aproximações da sua série de Taylor. 
Faça a derivação da função dada a partir da referida série de Taylor, apresentando todos os cálculos justificativos, tal como se faz para outras funções no capítulo respectivo do texto base desta UC \cite{Ol98-24}.

\Problema

Quem em Braga observar, ao fim da tarde, o tráfego onde a Avenida Clairmont
Fernand se junta à N101, aproximadamente na coordenada \href{https://maps.app.goo.gl/uCbXLsdibYoochr36}{41°33'46.8"N
8°24'32.4"W} --- ver as setas da figura que se segue --- reparará nas sequências
imparáveis (infinitas!) de veículos provenientes dessas vias de circulação.

Mas também irá observar um comportamento interessante por parte dos condutores desses
veículos: por regra, \emph{cada carro numa via deixa passar, à sua frente, exactamente outro carro da outra via}. 

\begin{center}
	\mapa
\end{center}

Este comportamento \emph{civilizado} chama-se \emph{fair-merge} (ou \emph{fair-interleaving})
de duas sequências infinitas, também designadas \emph{streams} em ciência
da computação. Seja dado o tipo dessas sequências em Haskell,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Stream}\;\Varid{a}\mathrel{=}\Conid{Cons}\;(\Varid{a},\Conid{Stream}\;\Varid{a})\;\mathbf{deriving}\;\Conid{Show}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
para o qual se define também:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathsf{out}\;(\Conid{Cons}\;(\Varid{x},\Varid{xs}))\mathrel{=}(\Varid{x},\Varid{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\noindent O referido comportamento civilizado pode definir-se, em Haskell,
da forma seguinte:\footnote{O facto das sequências serem infinitas não nos
deve preocupar, pois em Haskell isso é lidado de forma transparente por \lazy{lazy
evaluation}.}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fair\char95 merge}\mathbin{::}(\Conid{Stream}\;\Varid{a},\Conid{Stream}\;\Varid{a})+(\Conid{Stream}\;\Varid{a},\Conid{Stream}\;\Varid{a})\to \Conid{Stream}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{fair\char95 merge}\mathrel{=}\alt{\Varid{h}}{\Varid{k}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{h}\;(\Conid{Cons}\;(\Varid{x},\Varid{xs}),\Varid{y})\mathrel{=}\Conid{Cons}\;(\Varid{x},\Varid{k}\;(\Varid{xs},\Varid{y})){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{k}\;(\Varid{x},\Conid{Cons}\;(\Varid{y},\Varid{ys}))\mathrel{=}\Conid{Cons}\;(\Varid{y},\Varid{h}\;(\Varid{x},\Varid{ys})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Defina \ensuremath{\Varid{fair\char95 merge}} como um \textbf{anamorfismo} de \ensuremath{\Conid{Stream}}s, usando o combinador
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\lanabracket\,\Varid{g}\,\ranabracket\mathrel{=}\Conid{Cons}\comp (\Varid{id}\times\lanabracket\,\Varid{g}\,\ranabracket)\comp \Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
e a seguinte estratégia:
\begin{itemize}
\item	Derivar a lei \textbf{dual} da recursividade mútua,
\begin{eqnarray}
	\ensuremath{\alt{\Varid{f}}{\Varid{g}}\mathrel{=}\ana{\alt{\Varid{h}}{\Varid{k}}}} & \equiv & \ensuremath{\begin{lcbr}\Varid{out}\comp \Varid{f}\mathrel{=}\fun F \;\alt{\Varid{f}}{\Varid{g}}\comp \Varid{h}\\\Varid{out}\comp \Varid{g}\mathrel{=}\fun F \;\alt{\Varid{f}}{\Varid{g}}\comp \Varid{k}\end{lcbr}}
	\label{eq:fokkinga_dual}
\end{eqnarray}
	tal como se fez, nas aulas, para a que está no formulário.
\item
	Usar (\ref{eq:fokkinga_dual}) na resolução do problema proposto. 
\end{itemize}
Justificar devidamente a resolução, que deverá vir acompanhada de diagramas explicativos.

\Problema

Como se sabe, é possível pensarmos em catamorfismos, anamorfismos etc \emph{probabilísticos},
quer dizer, programas recursivos que dão distribuições como resultados. Por
exemplo, podemos pensar num combinador
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pcataList}\mathbin{::}(()+(\Varid{a},\Varid{b})\to \fun{Dist}\;\Varid{b})\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to \fun{Dist}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que é muito parecido com
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\llparenthesis\, \cdot \,\rrparenthesis\mathbin{::}(()+(\Varid{a},\Varid{b})\to \Varid{b})\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to \Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
da biblioteca \List. A principal diferença é que o gene de \ensuremath{\Varid{pcataList}} é uma função probabilística.

Como exemplo de utilização, recorde-se que \ensuremath{\llparenthesis\, \alt{\Varid{zero}}{\Varid{add}}\,\rrparenthesis} soma todos
os elementos da lista argumento, por exemplo:
\begin{quote}
\ensuremath{\llparenthesis\, \alt{\Varid{zero}}{\Varid{add}}\,\rrparenthesis\;[\mskip1.5mu \mathrm{20},\mathrm{10},\mathrm{5}\mskip1.5mu]\mathrel{=}\mathrm{35}}.
\end{quote}
Considere-se agora a função \ensuremath{\Varid{padd}} (adição probabilística) que,
com probabilidade $90\%$ soma dois números e com probabilidade $10\%$ os subtrai:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{padd}\;(\Varid{a},\Varid{b})\mathrel{=}\Conid{D}\;[\mskip1.5mu (\Varid{a}\mathbin{+}\Varid{b},\mathrm{0.9}),(\Varid{a}\mathbin{-}\Varid{b},\mathrm{0.1})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Se se correr
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{d4}\mathrel{=}\Varid{pcataList}\;\alt{\Varid{pzero}}{\Varid{padd}}\;[\mskip1.5mu \mathrm{20},\mathrm{10},\mathrm{5}\mskip1.5mu]\;\mathbf{where}\;\Varid{pzero}\mathrel{=}\Varid{return}\comp \Varid{zero}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
obter-se-á:
\begin{Verbatim}[fontsize=\small]
35  81.0%
25   9.0%
 5   9.0%
15   1.0%
\end{Verbatim}

Com base neste exemplo, resolva o seguinte
\begin{quote}\em
\textbf{Problema}: Uma unidade militar pretende enviar uma mensagem urgente
a outra, mas tem o aparelho de telegrafia meio avariado. Por experiência,
o telegrafista sabe que a probabilidade de uma palavra se perder (não ser
transmitida) é $5\%$; e que, no final de cada mensagem, o aparelho envia o código
\ensuremath{\text{\ttfamily \char34 stop\char34}}, mas (por estar meio avariado), falha $10\%$ das vezes.

Qual a probabilidade de a palavra \ensuremath{\text{\ttfamily \char34 atacar\char34}} da mensagem 
\begin{quote}
\ensuremath{\Varid{words}\;\text{\ttfamily \char34 Vamos~atacar~hoje\char34}}
\end{quote}
se perder, isto é, o resultado da transmissão ser \ensuremath{[\mskip1.5mu \text{\ttfamily \char34 Vamos\char34},\text{\ttfamily \char34 hoje\char34},\text{\ttfamily \char34 stop\char34}\mskip1.5mu]}?
E a de seguirem todas as palavras, mas faltar o \ensuremath{\text{\ttfamily \char34 stop\char34}} no fim? E a da transmissão
ser perfeita?
\end{quote}

Responda a estas perguntas encontrando \ensuremath{\Varid{gene}} tal que
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{transmitir}\mathrel{=}\Varid{pcataList}\;\Varid{gene}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
descreve o comportamento do aparelho.
Justificar devidamente a resolução, que deverá vir acompanhada de diagramas explicativos.
%

\part*{Anexos}

\appendix

\section{Natureza do trabalho a realizar}
\label{sec:documentacao}
Este trabalho teórico-prático deve ser realizado por grupos de 3 alunos.
Os detalhes da avaliação (datas para submissão do relatório e sua defesa
oral) são os que forem publicados na \cp{página da disciplina} na \emph{internet}.

Recomenda-se uma abordagem participativa dos membros do grupo em \textbf{todos}
os exercícios do trabalho, para assim poderem responder a qualquer questão
colocada na \emph{defesa oral} do relatório.

Para cumprir de forma integrada os objectivos do trabalho vamos recorrer
a uma técnica de programa\-ção dita ``\litp{literária}'' \cite{Kn92}, cujo
princípio base é o seguinte:
%
\begin{quote}\em
        Um programa e a sua documentação devem coincidir.
\end{quote}
%
Por outras palavras, o \textbf{código fonte} e a \textbf{documentação} de um
programa deverão estar no mesmo ficheiro.

O ficheiro \texttt{cp2526t.pdf} que está a ler é já um exemplo de
\litp{programação literária}: foi gerado a partir do texto fonte
\texttt{cp2526t.lhs}\footnote{O sufixo `lhs' quer dizer
\emph{\lhaskell{literate Haskell}}.} que encontrará no \MaterialPedagogico\
desta disciplina des\-com\-pactando o ficheiro \texttt{cp2526t.zip}.

Como se mostra no esquema abaixo, de um único ficheiro (\ensuremath{\Varid{lhs}})
gera-se um PDF ou faz-se a interpretação do código \Haskell\ que ele inclui:

        \esquema

Vê-se assim que, para além do \GHCi, serão necessários os executáveis \PdfLatex\ e
\LhsToTeX. Para facilitar a instalação e evitar problemas de versões e
conflitos com sistemas operativos, é recomendado o uso do \Docker\ tal como
a seguir se descreve.

\section{Docker} \label{sec:docker}

Recomenda-se o uso do \container\ cuja imagem é gerada pelo \Docker\ a partir do ficheiro
\texttt{Dockerfile} que se encontra na diretoria que resulta de descompactar
\texttt{cp2526t.zip}. Este \container\ deverá ser usado na execução
do \GHCi\ e dos comandos relativos ao \Latex. (Ver também a \texttt{Makefile}
que é disponibilizada.)

Após \href{https://docs.docker.com/engine/install/}{instalar o Docker} e
descarregar o referido zip com o código fonte do trabalho,
basta executar os seguintes comandos:
\begin{Verbatim}[fontsize=\small]
    $ docker build -t cp2526t .
    $ docker run -v ${PWD}:/cp2526t -it cp2526t
\end{Verbatim}
\textbf{NB}: O objetivo é que o container\ seja usado \emph{apenas} 
para executar o \GHCi\ e os comandos relativos ao \Latex.
Deste modo, é criado um \textit{volume} (cf.\ a opção \texttt{-v \$\{PWD\}:/cp2526t}) 
que permite que a diretoria em que se encontra na sua máquina local 
e a diretoria \texttt{/cp2526t} no \container\ sejam partilhadas.

Pretende-se então que visualize/edite os ficheiros na sua máquina local e que
os compile no \container, executando:
\begin{Verbatim}[fontsize=\small]
    $ lhs2TeX cp2526t.lhs > cp2526t.tex
    $ pdflatex cp2526t
\end{Verbatim}
\LhsToTeX\ é o pre-processador que faz ``pretty printing'' de código Haskell
em \Latex\ e que faz parte já do \container. Alternativamente, basta executar
\begin{Verbatim}[fontsize=\small]
    $ make
\end{Verbatim}
para obter o mesmo efeito que acima.

Por outro lado, o mesmo ficheiro \texttt{cp2526t.lhs} é executável e contém
o ``kit'' básico, escrito em \Haskell, para realizar o trabalho. Basta executar
\begin{Verbatim}[fontsize=\small]
    $ ghci cp2526t.lhs
\end{Verbatim}

\noindent Abra o ficheiro \texttt{cp2526t.lhs} no seu editor de texto preferido
e verifique que assim é: todo o texto que se encontra dentro do ambiente
\begin{quote}\small\tt
\text{\ttfamily \char92{}begin\char123{}code\char125{}}
\\ ... \\
\text{\ttfamily \char92{}end\char123{}code\char125{}}
\end{quote}
é seleccionado pelo \GHCi\ para ser executado.

\section{Em que consiste o TP}

Em que consiste, então, o \emph{relatório} a que se referiu acima?
É a edição do texto que está a ser lido, preenchendo o anexo \ref{sec:resolucao}
com as respostas. O relatório deverá conter ainda a identificação dos membros
do grupo de trabalho, no local respectivo da folha de rosto.

Para gerar o PDF integral do relatório deve-se ainda correr os comando seguintes,
que actualizam a bibliografia (com \Bibtex) e o índice remissivo (com \Makeindex),
\begin{Verbatim}[fontsize=\small]
    $ bibtex cp2526t.aux
    $ makeindex cp2526t.idx
\end{Verbatim}
e recompilar o texto como acima se indicou. (Como já se disse, pode fazê-lo
correndo simplesmente \texttt{make} no \container.)

No anexo \ref{sec:codigo} disponibiliza-se algum código \Haskell\ relativo
aos problemas que são colocados. Esse anexo deverá ser consultado e analisado
à medida que isso for necessário.

Deve ser feito uso da \litp{programação literária} para documentar bem o código que se
desenvolver, em particular fazendo diagramas explicativos do que foi feito e
tal como se explica no anexo \ref{sec:diagramas} que se segue.

\section{Como exprimir cálculos e diagramas em LaTeX/lhs2TeX} \label{sec:diagramas}

Como primeiro exemplo, estudar o texto fonte (\lhstotex{lhs}) do que está a ler\footnote{
Procure e.g.\ por \texttt{"sec:diagramas"}.} onde se obtém o efeito seguinte:\footnote{Exemplos
tirados de \cite{Ol98-24}.}
\begin{eqnarray*}
\start
\ensuremath{\Varid{id}\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}
\just\equiv{ universal property }
\ensuremath{\begin{lcbr}\p1\comp \Varid{id}\mathrel{=}\Varid{f}\\\p2\comp \Varid{id}\mathrel{=}\Varid{g}\end{lcbr}}
\just\equiv{ identity }
\ensuremath{\begin{lcbr}\p1\mathrel{=}\Varid{f}\\\p2\mathrel{=}\Varid{g}\end{lcbr}}
\qed
\end{eqnarray*}

Os diagramas podem ser produzidos recorrendo à \emph{package} \Xymatrix, por exemplo:
\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\N_0}
           \ar[d]_-{\ensuremath{\cataNat{\Varid{g}}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\N_0}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\cataNat{\Varid{g}}}}
           \ar[l]_-{\ensuremath{\mathsf{in}}}
\\
     \ensuremath{\Conid{B}}
&
     \ensuremath{\mathrm{1}\mathbin{+}\Conid{B}}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}

\section{O mónade das distribuições probabilísticas} \label{sec:probabilities}
Mónades são functores com propriedades adicionais que nos permitem obter
efeitos especiais em progra\-mação. Por exemplo, a biblioteca \Probability\
oferece um mónade para abordar problemas de probabilidades. Nesta biblioteca,
o conceito de distribuição estatística é captado pelo tipo
\begin{eqnarray}
     \ensuremath{\mathbf{newtype}\;\fun{Dist}\;\Varid{a}\mathrel{=}\Conid{D}\;\{\mskip1.5mu \Varid{unD}\mathbin{::}[\mskip1.5mu (\Varid{a},\Conid{ProbRep})\mskip1.5mu]\mskip1.5mu\}}
     \label{eq:Dist}
\end{eqnarray}
em que \ensuremath{\Conid{ProbRep}} é um real de \ensuremath{\mathrm{0}} a \ensuremath{\mathrm{1}}, equivalente a uma escala de $0$ a
$100 \%$.

Cada par \ensuremath{(\Varid{a},\Varid{p})} numa distribuição \ensuremath{\Varid{d}\mathbin{::}\fun{Dist}\;\Varid{a}} indica que a probabilidade
de \ensuremath{\Varid{a}} é \ensuremath{\Varid{p}}, devendo ser garantida a propriedade de  que todas as probabilidades
de \ensuremath{\Varid{d}} somam $100\%$.
Por exemplo, a seguinte distribuição de classificações por escalões de $A$ a $E$,
\[
\begin{array}{ll}
A & \rule{2mm}{3pt}\ 2\%\\
B & \rule{12mm}{3pt}\ 12\%\\
C & \rule{29mm}{3pt}\ 29\%\\
D & \rule{35mm}{3pt}\ 35\%\\
E & \rule{22mm}{3pt}\ 22\%\\
\end{array}
\]
será representada pela distribuição
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{d1}\mathbin{::}\fun{Dist}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}\Varid{d1}\mathrel{=}\Conid{D}\;[\mskip1.5mu (\text{\ttfamily 'A'},\mathrm{0.02}),(\text{\ttfamily 'B'},\mathrm{0.12}),(\text{\ttfamily 'C'},\mathrm{0.29}),(\text{\ttfamily 'D'},\mathrm{0.35}),(\text{\ttfamily 'E'},\mathrm{0.22})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que o \GHCi\ mostrará assim:
\begin{Verbatim}[fontsize=\small]
'D'  35.0%
'C'  29.0%
'E'  22.0%
'B'  12.0%
'A'   2.0%
\end{Verbatim}
É possível definir geradores de distribuições, por exemplo distribuições \emph{uniformes},
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{d2}\mathrel{=}\Varid{uniform}\;(\Varid{words}\;\text{\ttfamily \char34 Uma~frase~de~cinco~palavras\char34}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
isto é
\begin{Verbatim}[fontsize=\small]
     "Uma"  20.0%
   "cinco"  20.0%
      "de"  20.0%
   "frase"  20.0%
"palavras"  20.0%
\end{Verbatim}
distribuição \emph{normais}, eg.\
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{d3}\mathrel{=}\Varid{normal}\;[\mskip1.5mu \mathrm{10}\mathinner{\ldotp\ldotp}\mathrm{20}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
etc.\footnote{Para mais detalhes ver o código fonte de \Probability, que é uma adaptação da
biblioteca \PFP\ (``Probabilistic Functional Programming''). Para quem quiser saber mais
recomenda-se a leitura do artigo \cite{EK06}.}
\ensuremath{\fun{Dist}} forma um \textbf{mónade} cuja unidade é \ensuremath{\Varid{return}\;\Varid{a}\mathrel{=}\Conid{D}\;[\mskip1.5mu (\Varid{a},\mathrm{1})\mskip1.5mu]} e cuja composição de Kleisli
é (simplificando a notação)
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}(\Varid{f}\kcomp \Varid{g})\;\Varid{a}\mathrel{=}[\mskip1.5mu (\Varid{y},\Varid{q}\mathbin{*}\Varid{p})\mid (\Varid{x},\Varid{p})\leftarrow \Varid{g}\;\Varid{a},(\Varid{y},\Varid{q})\leftarrow \Varid{f}\;\Varid{x}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
em que \ensuremath{\Varid{g}\mathbin{:}\Conid{A}\to \fun{Dist}\;\mathit B} e \ensuremath{\Varid{f}\mathbin{:}\mathit B\to \fun{Dist}\;\mathit C} são funções \textbf{monádicas} que representam
\emph{computações probabilísticas}.

Este mónade é adequado à resolução de problemas de \emph{probabilidades e estatística} usando programação funcional, de forma elegante e como caso particular da programação monádica.

\section{Código fornecido}\label{sec:codigo}

\subsection*{Problema 1}

Árvores exemplo:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}t_1 \mathbin{::}\Conid{BTree}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}t_1 \mathrel{=}\Conid{Node}\;(\mathrm{5},(\Conid{Node}\;(\mathrm{3},(\Conid{Node}\;(\mathrm{1},(\Conid{Empty},\Conid{Empty})),\Conid{Node}\;(\mathrm{4},(\Conid{Empty},\Conid{Empty})))),{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\Conid{Node}\;(\mathrm{7},(\Conid{Node}\;(\mathrm{6},(\Conid{Empty},\Conid{Empty})),\Conid{Node}\;(\mathrm{8},(\Conid{Empty},\Conid{Empty})))))){}\<[E]%
\\[\blanklineskip]%
\>[B]{}t_2 \mathbin{::}\Conid{BTree}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}t_2 \mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{node}\;\mathrm{1}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{node}\;\mathrm{2}\;(\Varid{node}\;\mathrm{4}\;\Conid{Empty}\;\Conid{Empty})\;(\Varid{node}\;\mathrm{5}\;\Conid{Empty}\;\Conid{Empty}))\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{node}\;\mathrm{3}\;(\Varid{node}\;\mathrm{6}\;\Conid{Empty}\;\Conid{Empty})\;(\Varid{node}\;\mathrm{7}\;\Conid{Empty}\;\Conid{Empty})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}t_3 \mathbin{::}\Conid{BTree}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}t_3 \mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{node}\;\text{\ttfamily 'A'}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{node}\;\text{\ttfamily 'B'}\;(\Varid{node}\;\text{\ttfamily 'C'}\;(\Varid{node}\;\text{\ttfamily 'D'}\;\Conid{Empty}\;\Conid{Empty})\;\Conid{Empty})\;\Conid{Empty})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{node}\;\text{\ttfamily 'E'}\;\Conid{Empty}\;\Conid{Empty}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}t_4 \mathbin{::}\Conid{BTree}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}t_4 \mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{node}\;\text{\ttfamily 'A'}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{node}\;\text{\ttfamily 'B'}\;(\Varid{node}\;\text{\ttfamily 'C'}\;(\Varid{node}\;\text{\ttfamily 'D'}\;\Conid{Empty}\;\Conid{Empty})\;\Conid{Empty})\;\Conid{Empty})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Empty}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}t_5 \mathbin{::}\Conid{BTree}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}t_5 \mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{node}\;\mathrm{1}\;{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}(\Varid{node}\;\mathrm{2}\;(\Varid{node}\;\mathrm{4}\;\Conid{Empty}\;\Conid{Empty})\;\Conid{Empty})\;{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}(\Varid{node}\;\mathrm{3}\;\Conid{Empty}\;(\Varid{node}\;\mathrm{5}\;(\Varid{node}\;\mathrm{6}\;\Conid{Empty}\;\Conid{Empty})\;\Conid{Empty})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{node}\;\Varid{a}\;\Varid{b}\;\Varid{c}\mathrel{=}\Conid{Node}\;(\Varid{a},(\Varid{b},\Varid{c})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%----------------- Soluções dos alunos -----------------------------------------%

\section{Soluções dos alunos}\label{sec:resolucao}
Os alunos devem colocar neste anexo as suas soluções para os exercícios
propostos, de acordo com o ``layout'' que se fornece.
Não podem ser alterados os nomes ou tipos das funções dadas, mas pode ser
adicionado texto ao anexo, bem como diagramas e/ou outras funções auxiliares
que sejam necessárias.

\noindent
\textbf{Importante}: Não pode ser alterado o texto deste ficheiro fora deste anexo.

\subsection*{Problema 1}

\subsubsection*{Solução 1: catamorfismo}

\subsubsection*{Análise intuitiva do problema}

Como primeira proposta é desejado que a travessia se baseie num catamorfismo de árvores binárias.

Intuitivamente, dado que desejamos uma travessia por níveis (\emph{breadth-first}), precisamos de uma
recursão que percorra a árvore e devolva os elementos ordenados por níveis. Ora, uma recursão implicitamente
faz uma travessia em profundidade (\emph{depth-first}), pelo que teremos de manipular o resultado dessa recursão para obter o
resultado desejado.

Inicie-se o processo por analisar ambas as funções dadas, \ensuremath{\Varid{bfsLevels}} e \ensuremath{\Varid{bft}},
de modo a a perceber o que cada uma delas deve fazer.

A função \ensuremath{\Varid{bfsLevels}}, dado uma árvore binária de elementos de tipo \ensuremath{\Conid{A}}, deve devolver uma lista de elementos de \ensuremath{\Conid{A}},
ordenados por níveis, ou seja, primeiro os elementos do nível 0 (a raiz), depois os do nível 1 (os filhos da raiz), depois os do nível 2 (os netos da raiz), e assim sucessivamente.
Esta função é definida à custa de um \ensuremath{\Varid{concat}} após um catamorfismo \ensuremath{\Varid{levels}}.

O catamorfismo \ensuremath{\Varid{levels}}, por sua vez, deve devolver uma lista de listas de elementos de \ensuremath{\Conid{A}},
onde cada lista interna corresponde a um nível da árvore.

Exemplifique-se o funcionamento deste algoritmo para um entendimento claro do que se pretende alcançar. Dada a árvore \ensuremath{t_1 }, o catamorfismo \ensuremath{\Varid{levels}\;t_1 } deve devolver a lista de listas \ensuremath{[\mskip1.5mu [\mskip1.5mu \mathrm{5}\mskip1.5mu],[\mskip1.5mu \mathrm{3},\mathrm{7}\mskip1.5mu],[\mskip1.5mu \mathrm{1},\mathrm{4},\mathrm{6},\mathrm{8}\mskip1.5mu]\mskip1.5mu]}. A função \ensuremath{\Varid{bfsLevels}\;t_1 }, por sua vez, deve devolver a lista resultante da concatenação das listas internas, ou seja, \ensuremath{[\mskip1.5mu \mathrm{5},\mathrm{3},\mathrm{7},\mathrm{1},\mathrm{4},\mathrm{6},\mathrm{8}\mskip1.5mu]}.

\subsubsection*{Definição do catamorfismo}

O objetivo é definir o gene \ensuremath{\Varid{glevels}} de \ensuremath{\Varid{levels}}, de modo a que este catamorfismo devolva a lista de listas de elementos de \ensuremath{\Conid{A}} ordenados por níveis.

Represente-se esquematicamente este catamorfismo:

\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\Conid{BTree}\;\Conid{A}}
           \ar[d]_-{\ensuremath{\llparenthesis\, \Varid{glevels}\,\rrparenthesis}}
           \ar[r]^-{\ensuremath{\mathsf{out}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\times(\Conid{BTree}\;\Conid{A}\times\Conid{BTree}\;\Conid{A})}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{id}\times(\llparenthesis\, \Varid{glevels}\,\rrparenthesis\times\llparenthesis\, \Varid{glevels}\,\rrparenthesis)}}
\\
     \ensuremath{[\mskip1.5mu [\mskip1.5mu \Conid{A}\mskip1.5mu]\mskip1.5mu]}
&
     \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\times([\mskip1.5mu [\mskip1.5mu \Conid{A}\mskip1.5mu]\mskip1.5mu]\times[\mskip1.5mu [\mskip1.5mu \Conid{A}\mskip1.5mu]\mskip1.5mu])}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}

Devido à existência do coproduto, sabe-se que o gene do catamorfismo será uma função definida por:
\begin{eqnarray}
     \ensuremath{\Varid{g}\mathrel{=}[\mskip1.5mu \Varid{g1},\Varid{g2}\mskip1.5mu]}
\label{eq:glevels}
\end{eqnarray}

Para definir o gene, considere-se o que deve acontecer nos dois casos possíveis
da árvore dada como argumento:
\begin{itemize}
\item No caso base, em que a árvore é vazia (\ensuremath{\Conid{Empty}}), a lista de níveis deve ser a lista vazia (\ensuremath{[\mskip1.5mu \mskip1.5mu]}).
\item No caso recursivo, em que a árvore é um nó \ensuremath{\Conid{Node}\;(\Varid{a},(\Varid{l},\Varid{r}))}, com raiz \ensuremath{\Varid{a}} e subárvores \ensuremath{\Varid{l}} e \ensuremath{\Varid{r}},
devem ser combinadas as listas de níveis das subárvores \ensuremath{\Varid{l}} e \ensuremath{\Varid{r}}, adicionando-se o elemento \ensuremath{\Varid{a}} a 
essa combinação de forma pertinente.
\end{itemize}

O caso base é simples de definir:
\begin{eqnarray}
     \ensuremath{\Varid{g1}\mathrel{=}\Varid{nil}}
\label{eq:g1}
\end{eqnarray}

Para o caso recursivo, defina-se uma função auxiliar \ensuremath{\Varid{concatPointWise}}: 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{concatPointWise}\mathbin{::}[\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{concatPointWise}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{ys}\mathrel{=}\Varid{ys}{}\<[E]%
\\
\>[B]{}\Varid{concatPointWise}\;\Varid{xs}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\Varid{xs}{}\<[E]%
\\
\>[B]{}\Varid{concatPointWise}\;(\Varid{x}\mathbin{:}\Varid{xs})\;(\Varid{y}\mathbin{:}\Varid{ys})\mathrel{=}(\Varid{x}\mathbin{+\!\!+}\Varid{y})\mathbin{:}\Varid{concatPointWise}\;\Varid{xs}\;\Varid{ys}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Esta função trata de concatenar duas listas de listas de elementos do tipo \ensuremath{\Conid{A}}.
Isto trata de juntar os níveis das duas listas, ponto a ponto. A primeira claúsula
trata do caso em que a primeira lista é vazia, retornando a segunda lista. A segunda claúsula trata do caso em que a segunda lista é vazia, retornando a
primeira lista. A terceira claúsula trata do caso em que ambas as listas são não vazias,
concatenando as cabeças das listas e chamando-se recursivamente para as caudas.
Por exemplo,
\begin{quote}
\ensuremath{\Varid{concatPointWise}\;[\mskip1.5mu [\mskip1.5mu \mathrm{3}\mskip1.5mu],[\mskip1.5mu \mathrm{1},\mathrm{4}\mskip1.5mu]\mskip1.5mu]\;[\mskip1.5mu [\mskip1.5mu \mathrm{7}\mskip1.5mu],[\mskip1.5mu \mathrm{6},\mathrm{8}\mskip1.5mu]\mskip1.5mu]\mathrel{=}[\mskip1.5mu [\mskip1.5mu \mathrm{3},\mathrm{7}\mskip1.5mu],[\mskip1.5mu \mathrm{1},\mathrm{4},\mathrm{6},\mathrm{8}\mskip1.5mu]\mskip1.5mu]}
\end{quote}


Assim, o gene \ensuremath{\Varid{g2}} pode ser definido como:
\begin{eqnarray}
     \ensuremath{\Varid{g2}\;(\Varid{a},(\Varid{ls},\Varid{rs}))\mathrel{=}\Varid{singl}\;\Varid{a}\mathbin{+\!\!+}\Varid{concatPointWise}\;\Varid{ls}\;\Varid{rs}}
\label{eq:g2}
\end{eqnarray}

Em que \ensuremath{\Varid{ls}} e \ensuremath{\Varid{rs}} são as listas de níveis das subárvores \ensuremath{\Varid{l}} e \ensuremath{\Varid{r}}, respetivamente.
O resultado é a lista de níveis das subárvores, combinadas ponto a ponto, com o elemento \ensuremath{\Varid{a}} adicionado
como novo nível no início da lista.

Que, transformando em uma versão pointfree, resulta em:
\begin{eqnarray}
     \ensuremath{\Varid{g2}\mathrel{=}\Varid{cons}\comp (\Varid{singl}\times\uncurry{\Varid{concatPointWise}})}
\label{eq:g2_pointfree}
\end{eqnarray}

\subsubsection*{Definição de \ensuremath{\Varid{glevels}}}

Com base nas equações (\ref{eq:glevels}), (\ref{eq:g1}) e (\ref{eq:g2_pointfree}),
A definição final de \ensuremath{\Varid{glevels}} é:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{glevels}\mathrel{=}\alt{\Varid{nil}}{\Varid{cons}\comp (\Varid{singl}\times\uncurry{\Varid{concatPointWise}})}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection*{Definição pointfree da função auxiliar}

Com o intuito de embelezar a nossa solução, optámos por desafiar-nos a definir a função de concatenação ponto a ponto
\ensuremath{\Varid{concatPointWise}} de forma pointfree através de um anamorfismo de listas.

Recordemos que a função \ensuremath{\Varid{concatPointWise}} recebe duas listas de listas e combina-as ponto a ponto.
Podemos pensá-la como um processo iterativo que constrói progressivamente a lista resultado,
o que sugere o uso de um \textbf{anamorfismo}.

O anamorfismo de listas tem a forma:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\anaList{\Varid{g}}\mathrel{=}\mathsf{in}_{List}\comp (\Varid{id}\mathbin{+}\Varid{id}\times\anaList{\Varid{g}})\comp \Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

O gene \ensuremath{\Varid{g}} recebe um estado (neste caso, o par de listas \ensuremath{([\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu],[\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu])}) e decide:
\begin{itemize}
\item Se deve parar (devolvendo \ensuremath{i_1\;()})
\item Ou produzir o próximo elemento e o novo estado (devolvendo \ensuremath{i_2\;(\Varid{elemento},\Varid{novo\char95 estado})})
\end{itemize}

Definamos então \ensuremath{\Varid{concatCondicional}} como um anamorfismo:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{concatCondicional}\mathbin{::}[\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Varid{a}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{concatCondicional}\mathrel{=}\overline{\anaList{\Varid{gene}}}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{gene}\mathrel{=}\mcond{\Varid{ambasVazias}}{\Varid{stop}}{\cdot }{}\<[E]%
\\
\>[7]{}\hsindent{7}{}\<[14]%
\>[14]{}(\mcond{\Varid{listaEsquerdaVazia}}{\Varid{doListaDireita}}{\cdot }{}\<[E]%
\\
\>[7]{}\hsindent{7}{}\<[14]%
\>[14]{}\mcond{\Varid{listaDireitaVazia}}{\Varid{doListaEsquerda}}{\Varid{doAmbas}}){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mbox{\onelinecomment  Predicados}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{ambasVazias}\mathrel{=}\uncurry{(\mathrel{\wedge})}\comp (\Varid{null}\times\Varid{null}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{listaEsquerdaVazia}\mathrel{=}\Varid{null}\comp \p1{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{listaDireitaVazia}\mathrel{=}\Varid{null}\comp \p2{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mbox{\onelinecomment  Ações}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{stop}\mathrel{=}i_1\comp \underline{}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{doListaDireita}\mathrel{=}i_2\comp \conj{\Varid{head}\comp \p2}{\conj{\Varid{nil}}{\Varid{tail}\comp \p2}}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{doListaEsquerda}\mathrel{=}i_2\comp \conj{\Varid{head}\comp \p1}{\conj{\Varid{tail}\comp \p1}{\Varid{nil}}}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{doAmbas}\mathrel{=}i_2\comp \conj{\mathsf{conc}\comp (\Varid{head}\times\Varid{head})}{\Varid{tail}\times\Varid{tail}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\textbf{Explicação detalhada do gene:}

O gene implementa uma máquina de estados que analisa o par de listas e decide como proceder.
Usa uma cascata de condicionais (\ensuremath{\Varid{cond}\;\Varid{p}\;\Varid{f}\;\Varid{g}}) que funciona como \ensuremath{\mathbf{if}\;\Varid{p}\;\mathbf{then}\;\Varid{f}\;\mathbf{else}\;\Varid{g}}:

\begin{enumerate}
\item \textbf{Caso base - ambas as listas vazias} \ensuremath{([\mskip1.5mu \mskip1.5mu],[\mskip1.5mu \mskip1.5mu])}: 
   
   Quando não há mais elementos em nenhuma das listas, o processo termina.
   O gene devolve \ensuremath{i_1\;()} para sinalizar paragem ao anamorfismo.
   
   \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\Varid{stop}\mathrel{=}i_1\comp \underline{}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
   
   Este é o critério de terminação que garante que a recursão não é infinita.

\item \textbf{Caso degenerado - só a lista esquerda está vazia} \ensuremath{([\mskip1.5mu \mskip1.5mu],\Varid{y}\mathbin{:}\Varid{ys})}: 
   
   Neste caso, não há mais elementos da lista esquerda para combinar, mas ainda
   existem elementos em \ensuremath{\Varid{ys}} que devem ser incluídos no resultado final.
   
   A ação \ensuremath{\Varid{doListaDireita}} constrói o próximo elemento da lista resultado e o novo estado:
   \begin{itemize}
   \item \textbf{Elemento emitido}: \ensuremath{\Varid{head}\comp \p2} extrai \ensuremath{\Varid{y}} (a primeira sublista de \ensuremath{\Varid{ys}})
   \item \textbf{Novo estado}: \ensuremath{([\mskip1.5mu \mskip1.5mu],\Varid{tail}\comp \p2)} resulta em \ensuremath{([\mskip1.5mu \mskip1.5mu],\Varid{ys'})} onde \ensuremath{\Varid{ys'}} são as sublistas restantes
   \end{itemize}
   
   \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\Varid{doListaDireita}\mathrel{=}i_2\comp \conj{\Varid{head}\comp \p2}{\conj{\Varid{nil}}{\Varid{tail}\comp \p2}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
   
   Em termos práticos: como não há nada à esquerda, simplesmente copiamos \ensuremath{\Varid{y}} para o resultado
   e continuamos com \ensuremath{([\mskip1.5mu \mskip1.5mu],\Varid{ys'})}.

\item \textbf{Caso simétrico - só a lista direita está vazia} \ensuremath{(\Varid{x}\mathbin{:}\Varid{xs},[\mskip1.5mu \mskip1.5mu])}:
   
   Situação simétrica ao caso anterior: esgotaram-se os elementos de \ensuremath{\Varid{ys}} mas
   ainda há elementos em \ensuremath{\Varid{xs}} para processar.
   
   A ação \ensuremath{\Varid{doListaEsquerda}} funciona analogamente:
   \begin{itemize}
   \item \textbf{Elemento emitido}: \ensuremath{\Varid{head}\comp \p1} extrai \ensuremath{\Varid{x}} (a primeira sublista de \ensuremath{\Varid{xs}})
   \item \textbf{Novo estado}: \ensuremath{(\Varid{tail}\comp \p1,[\mskip1.5mu \mskip1.5mu])} resulta em \ensuremath{(\Varid{xs'},[\mskip1.5mu \mskip1.5mu])} onde \ensuremath{\Varid{xs'}} são as sublistas restantes
   \end{itemize}
   
   \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\Varid{doListaEsquerda}\mathrel{=}i_2\comp \conj{\Varid{head}\comp \p1}{\conj{\Varid{tail}\comp \p1}{\Varid{nil}}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
   
   Interpretação: copiamos \ensuremath{\Varid{x}} para o resultado e prosseguimos com \ensuremath{(\Varid{xs'},[\mskip1.5mu \mskip1.5mu])}.

\item \textbf{Caso geral - ambas as listas não-vazias} \ensuremath{(\Varid{x}\mathbin{:}\Varid{xs},\Varid{y}\mathbin{:}\Varid{ys})}:
   
   Este é o caso principal onde efetivamente combinamos elementos de ambas as listas.
   Queremos concatenar \ensuremath{\Varid{x}} com \ensuremath{\Varid{y}} (ambas são sublistas) e continuar o processo com
   os elementos restantes.
   
   A ação \ensuremath{\Varid{doAmbas}} realiza esta operação:
   \begin{itemize}
   \item \textbf{Elemento emitido}: \ensuremath{\mathsf{conc}\comp (\Varid{head}\times\Varid{head})} 
      \begin{itemize}
      \item \ensuremath{(\Varid{head}\times\Varid{head})} extrai \ensuremath{(\Varid{x},\Varid{y})} — as primeiras sublistas de cada lado
      \item \ensuremath{\mathsf{conc}} concatena-as, produzindo \ensuremath{\Varid{x}\mathbin{+\!\!+}\Varid{y}}
      \end{itemize}
   \item \textbf{Novo estado}: \ensuremath{(\Varid{tail}\times\Varid{tail})} produz \ensuremath{(\Varid{xs},\Varid{ys})} — os restantes elementos de ambas as listas
   \end{itemize}
   
   \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\Varid{doAmbas}\mathrel{=}i_2\comp \conj{\mathsf{conc}\comp (\Varid{head}\times\Varid{head})}{\Varid{tail}\times\Varid{tail}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
   
   Esta é a operação central da concatenação ponto a ponto: combinar \ensuremath{\Varid{x}} e \ensuremath{\Varid{y}} em \ensuremath{\Varid{x}\mathbin{+\!\!+}\Varid{y}}
   e avançar para o próximo par de sublistas.
\end{enumerate}

\textbf{Fluxo de controlo:}

A cascata de condicionais funciona como uma árvore de decisão:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{if}\;\Varid{ambasVazias}\;\mathbf{then}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{stop}{}\<[E]%
\\
\>[B]{}\mathbf{else}\;\mathbf{if}\;\Varid{listaEsquerdaVazia}\;\mathbf{then}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{doListaDireita}{}\<[E]%
\\
\>[B]{}\mathbf{else}\;\mathbf{if}\;\Varid{listaDireitaVazia}\;\mathbf{then}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{doListaEsquerda}{}\<[E]%
\\
\>[B]{}\mathbf{else}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{doAmbas}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Esta estrutura garante que tratamos todos os casos possíveis de forma exaustiva e mutuamente exclusiva.

\textbf{Exemplo de execução:}

Para \ensuremath{[\mskip1.5mu [\mskip1.5mu \mathrm{3}\mskip1.5mu],[\mskip1.5mu \mathrm{1},\mathrm{4}\mskip1.5mu]\mskip1.5mu]} e \ensuremath{[\mskip1.5mu [\mskip1.5mu \mathrm{7}\mskip1.5mu],[\mskip1.5mu \mathrm{6},\mathrm{8}\mskip1.5mu]\mskip1.5mu]}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{concatCondicional}\;[\mskip1.5mu [\mskip1.5mu \mathrm{3}\mskip1.5mu],[\mskip1.5mu \mathrm{1},\mathrm{4}\mskip1.5mu]\mskip1.5mu]\;[\mskip1.5mu [\mskip1.5mu \mathrm{7}\mskip1.5mu],[\mskip1.5mu \mathrm{6},\mathrm{8}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\mathrel{=}\anaList{\Varid{gene}}\;([\mskip1.5mu [\mskip1.5mu \mathrm{3}\mskip1.5mu],[\mskip1.5mu \mathrm{1},\mathrm{4}\mskip1.5mu]\mskip1.5mu],[\mskip1.5mu [\mskip1.5mu \mathrm{7}\mskip1.5mu],[\mskip1.5mu \mathrm{6},\mathrm{8}\mskip1.5mu]\mskip1.5mu]){}\<[E]%
\\
\>[B]{}\mathrel{=}\mbox{\onelinecomment  gene devolve i2 ([3,7], ([[1,4]], [[6,8]]))}{}\<[E]%
\\
\>[B]{}\mathrel{=}[\mskip1.5mu \mathrm{3},\mathrm{7}\mskip1.5mu]\mathbin{:}\anaList{\Varid{gene}}\;([\mskip1.5mu [\mskip1.5mu \mathrm{1},\mathrm{4}\mskip1.5mu]\mskip1.5mu],[\mskip1.5mu [\mskip1.5mu \mathrm{6},\mathrm{8}\mskip1.5mu]\mskip1.5mu]){}\<[E]%
\\
\>[B]{}\mathrel{=}\mbox{\onelinecomment  gene devolve i2 ([1,4,6,8], ([], []))}{}\<[E]%
\\
\>[B]{}\mathrel{=}[\mskip1.5mu \mathrm{3},\mathrm{7}\mskip1.5mu]\mathbin{:}[\mskip1.5mu \mathrm{1},\mathrm{4},\mathrm{6},\mathrm{8}\mskip1.5mu]\mathbin{:}\anaList{\Varid{gene}}\;([\mskip1.5mu \mskip1.5mu],[\mskip1.5mu \mskip1.5mu]){}\<[E]%
\\
\>[B]{}\mathrel{=}\mbox{\onelinecomment  gene devolve i1 ()}{}\<[E]%
\\
\>[B]{}\mathrel{=}[\mskip1.5mu [\mskip1.5mu \mathrm{3},\mathrm{7}\mskip1.5mu],[\mskip1.5mu \mathrm{1},\mathrm{4},\mathrm{6},\mathrm{8}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

E assim podemos definir a função glevels de forma mais elegante:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{glevels1}\mathrel{=}\alt{\Varid{nil}}{\Varid{cons}\comp (\Varid{singl}\times\uncurry{\Varid{concatCondicional}})}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsubsection*{Solução 2: anamorfismo}


\subsubsection*{Motivação: limitações da solução por catamorfismo}

A solução anterior baseada em \ensuremath{\Varid{levels}} funciona corretamente, mas tem uma ineficiência:
constrói toda a estrutura de níveis \ensuremath{[\mskip1.5mu [\mskip1.5mu \Conid{A}\mskip1.5mu]\mskip1.5mu]} para depois a concatenar. Para árvores grandes,
isto consome memória desnecessária.

Idealmente, gostaríamos de gerar diretamente a lista final \ensuremath{[\mskip1.5mu \Conid{A}\mskip1.5mu]} sem construir a estrutura
intermédia. Isto sugere o uso de um \textbf{anamorfismo}.

\subsubsection*{Intuição: processamento por níveis com uma fila}

Para fazer uma travessia \emph{breadth-first}, o algoritmo clássico usa uma fila (queue),
tal como sugerido no artigo \cite{Ok00}. Pensámos inicialmente num algoritmo iterativo
que funciona da seguinte forma:


\begin{enumerate}
\item Inicializamos a fila com a árvore argumento
\item Repetidamente:
   \begin{itemize}
   \item Retiramos uma árvore da frente da fila
   \item Se for \ensuremath{\Conid{Empty}}, ignoramos
   \item Se for \ensuremath{\Conid{Node}\;(\Varid{a},(\Varid{l},\Varid{r}))}, emitimos \ensuremath{\Varid{a}} e adicionamos \ensuremath{\Varid{l}} e \ensuremath{\Varid{r}} ao fim da fila
   \end{itemize}
\item Paramos quando a fila fica vazia
\end{enumerate}

\textbf{Exemplo ilustrativo}: Para a árvore \ensuremath{t_1 } o processamento da fila procede da seguinte forma:

\begin{center}
    \includegraphics[width=0.70\textwidth]{cp2526t_media/queue-example.png}
\end{center}

\emph{Nota}: Ocultam-se os \ensuremath{\Conid{Empty}}s para simplificar a ilustração.

\subsubsection*{Do algoritmo iterativo ao anamorfismo}

O algoritmo acima é iterativo e gera uma lista progressivamente, 
processando primeiro os nós de nível $n$ antes dos de nível $n+1$.
Esta estrutura corresponde precisamente a um anamorfismo de listas,
que constrói uma lista a partir de um estado através de um gene \ensuremath{\Varid{g}\mathbin{::}\mathit B\to \mathrm{1}\mathbin{+}\Conid{A}\times\mathit B}.

O gene recebe um estado \ensuremath{\mathit B} e devolve \ensuremath{i_1\;()} quando não há mais elementos (terminação),
ou \ensuremath{i_2\;(\Varid{a},\Varid{b'})} onde \ensuremath{\Varid{a}} é o próximo elemento a emitir e \ensuremath{\Varid{b'}} é o novo estado.
No nosso caso, o estado será a fila \ensuremath{[\mskip1.5mu \Conid{BTree}\;\Conid{A}\mskip1.5mu]} que contém as árvores ainda por processar.

Representemos o anamorfismo através do seguinte diagrama:

\begin{eqnarray*}
\xymatrix@C=2cm{
     \ensuremath{[\mskip1.5mu \Conid{BTree}\;\Conid{A}\mskip1.5mu]}
               \ar[d]_-{\ensuremath{\anaList{\Varid{g}}}}
               \ar[r]^-{\ensuremath{\Varid{g}}}
&    \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\times[\mskip1.5mu \Conid{BTree}\;\Conid{A}\mskip1.5mu]}
               \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{id}\times\anaList{\Varid{g}}}}
\\
     \ensuremath{[\mskip1.5mu \Conid{A}\mskip1.5mu]}
&     \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\times[\mskip1.5mu \Conid{A}\mskip1.5mu]}
               \ar[l]^-{\ensuremath{\mathsf{in}_{List}}}
}
\end{eqnarray*}

O gene \ensuremath{\Varid{g}\mathbin{::}[\mskip1.5mu \Conid{BTree}\;\Conid{A}\mskip1.5mu]\to \mathrm{1}\mathbin{+}\Conid{A}\times[\mskip1.5mu \Conid{BTree}\;\Conid{A}\mskip1.5mu]} deve inspecionar a fila e decidir o que fazer.
Caso esta esteja vazia, termina devolvendo \ensuremath{i_1\;()}; caso contrário, retira a primeira árvore,
emite a sua raiz e adiciona os filhos ao fim da fila. No entanto, se a árvore for \ensuremath{\Conid{Empty}},
deve ser ignorada e o gene deve processar o restante da fila recursivamente.

Podemos expressar isto de forma simples:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{g'}\mathbin{::}[\mskip1.5mu \Conid{BTree}\;\Varid{a}\mskip1.5mu]\to ()+(\Varid{a},[\mskip1.5mu \Conid{BTree}\;\Varid{a}\mskip1.5mu]){}\<[E]%
\\
\>[B]{}\Varid{g'}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}i_1\;(){}\<[E]%
\\
\>[B]{}\Varid{g'}\;(\Conid{Empty}\mathbin{:}\Varid{queue})\mathrel{=}\Varid{g'}\;\Varid{queue}{}\<[E]%
\\
\>[B]{}\Varid{g'}\;(\Conid{Node}\;(\Varid{a},(\Varid{l},\Varid{r}))\mathbin{:}\Varid{queue})\mathrel{=}i_2\;(\Varid{a},\Varid{queue}\mathbin{+\!\!+}[\mskip1.5mu \Varid{l},\Varid{r}\mskip1.5mu]){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A função \ensuremath{\Varid{bft}} inicia o processo com uma fila contendo apenas a árvore argumento,
aplicando depois o anamorfismo com o gene \ensuremath{\Varid{g'}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bft}\mathrel{=}\anaList{\Varid{g'}}\comp \Varid{singl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks



\subsection*{Problema 2}

Parta-se da definição matemática da série de Taylor do seno hiperbólico:
\[sinh \ x = \sum_{n=0}^{\infty} \frac{x^{2n+1}}{(2n+1)!} = x + \frac{x^3}{3!} + \frac{x^5}{5!} + \frac{x^7}{7!} + \ldots\]

A aproximação de \ensuremath{\Varid{sinh}\;\Varid{x}} com \ensuremath{\Varid{n}} termos da série será dada por:
\[sinh \ x \ n = \sum_{i=0}^{n-1} \frac{x^{2i+1}}{(2i+1)!}\]

\subsubsection*{Definição recursiva direta}

Podemos definir \ensuremath{\Varid{sinh}\;\Varid{x}\;\Varid{n}} recursivamente como:
\begin{equation}
sinh \ x \ n =
     \begin{cases}
          x & \text{se } n = 0\\
          \frac{x^{2(n-1)+1}}{(2(n-1)+1)!} + sinh \ x \ (n-1) & \text{se } n > 0
     \end{cases}
\end{equation}

No entanto, esta definição é ineficiente, pois cada termo envolve o cálculo de potências e fatoriais.

\subsubsection*{Descoberta de uma definição eficiente por recursividade mútua}

Podemos escrever a soma como uma recursão simples:

\begin{equation}
s \ x \ n =
     \begin{cases}
          x & \text{se } n = 0\\
          s \ x \ (n-1) + \frac{h \ x \ (n-1)}{k \ x \ (n-1)} & \text{se } n > 0
     \end{cases}
\end{equation}

onde \ensuremath{\Varid{s}\;\Varid{x}\;\Varid{n}} é a soma dos primeiros \ensuremath{\Varid{n}\mathbin{+}\mathrm{1}} termos, \ensuremath{\Varid{h}\;\Varid{x}\;\Varid{n}} é o numerador do termo \ensuremath{\Varid{n}} e \ensuremath{\Varid{k}\;\Varid{x}\;\Varid{n}} é o denominador do termo \ensuremath{\Varid{n}}.

\subsubsection*{Descoberta de \ensuremath{\Varid{h}} por recursividade mútua}

Observando que cada termo tem a forma $\frac{x^{2i+1}}{(2i+1)!}$, 
procuramos uma relação de recorrência para o numerador \ensuremath{\Varid{h}}.

Para o termo na posição \ensuremath{\Varid{n}}, o numerador é $x^{2n+1}$, e para o termo na posição \ensuremath{\Varid{n}\mathbin{+}\mathrm{1}}, 
o numerador é $x^{2(n+1)+1} = x^{2n+3}$.

A relação entre numeradores consecutivos é:
\[
h_{n+1} = x^{2n+3} = x^{2n+1} \cdot x^2 = h_n \cdot x^2
\]

Portanto, o numerador do próximo termo é $x^2$ vezes o numerador do termo atual.
Assim:

\begin{equation}
h \ x \ n =
     \begin{cases}
          x^3 & \text{se } n = 1\\
          x^2 \cdot h \ x \ (n-1) & \text{se } n > 1
     \end{cases}
\end{equation}

\subsubsection*{Descoberta de \ensuremath{\Varid{k}} por recursividade mútua (2ª iteração)}

Calculemos a relação de recorrência para o denominador \ensuremath{\Varid{k}}.
O denominador do termo na posição \ensuremath{\Varid{n}} considerando que este começa em \ensuremath{\Varid{n}\mathrel{=}\mathrm{1}}
é $(2n+3)!$. Para o termo na posição \ensuremath{\Varid{n}\mathbin{+}\mathrm{1}}, o denominador é $(2(n+1)+3)! = (2n+5)!$.
A relação entre denominadores consecutivos é:

\[\frac{k_{n+1}}{k_n} = \frac{(2n+5)!}{(2n+3)!} = (2n+5)(2n+4)\]

Portanto, o denominador do próximo termo é $(2n+5)(2n+4)$ vezes o denominador do termo atual.

Para o caso base \ensuremath{\Varid{n}\mathrel{=}\mathrm{1}}, temos \ensuremath{\Varid{k}\;\Varid{x}\;\mathrm{1}\mathrel{=}\mathrm{3}\mathbin{!}\mathrel{=}\mathrm{6}}.
Assim:

\begin{equation}
k \ x \ n =
     \begin{cases}
          6 & \text{se } n = 1\\
          k \ x \ n \cdot (2n+5)(2n+4) & \text{se } n > 1
     \end{cases}
\end{equation}

Aplicar-se-á a lei de recursividade mútua novamente para obter uma definição de \ensuremath{\Varid{k}} que não dependa de \ensuremath{\Varid{n}} diretamente.

\subsubsection*{Descoberta de \ensuremath{\Varid{j}} por recursividade mútua (3ª iteração)}

Introduzamos uma nova função \ensuremath{\Varid{j}\;\Varid{x}\;\Varid{n}\mathrel{=}(\mathrm{2}\;\Varid{n}\mathbin{+}\mathrm{5})\;(\mathrm{2}\;\Varid{n}\mathbin{+}\mathrm{4})} para simplificar a expressão de \ensuremath{\Varid{k}}.

Teremos uma relação entre termos consecutivos de \ensuremath{\Varid{j}} de:

\[j_{n+1} - j_n = (2(n+1)+5)(2(n+1)+4) - (2n+5)(2n+4) = 4n^2 + 26n + 42 - 4n^2 - 18n - 20 = 8n + 22\]

No caso base \ensuremath{\Varid{n}\mathrel{=}\mathrm{0}}, temos \ensuremath{\Varid{j}\;\Varid{x}\;\mathrm{0}\mathrel{=}(\mathrm{2}\mathbin{*}\mathrm{0}\mathbin{+}\mathrm{5})\;(\mathrm{2}\mathbin{*}\mathrm{0}\mathbin{+}\mathrm{4})\mathrel{=}\mathrm{20}}.

Portanto, podemos definir \ensuremath{\Varid{j}} como:

\begin{equation}
j \ x \ n =
     \begin{cases}
          20 & \text{se } n = 0\\
          j \ x \ n + 8n + 22 & \text{se } n > 0
     \end{cases}
\end{equation}

\subsubsection*{Descoberta de \ensuremath{\Varid{m}} por recursividade mútua (4ª iteração)}

Para simplificar ainda mais, introduzimos \ensuremath{\Varid{m}\;\Varid{x}\;\Varid{n}\mathrel{=}\mathrm{8}\;\Varid{n}\mathbin{+}\mathrm{22}}.

Temos então a relação entre termos consecutivos de \ensuremath{\Varid{m}} de:

\[m_{n+1} - m_n = 8(n+1) + 22 - (8n + 22) = 8\]

No caso base \ensuremath{\Varid{n}\mathrel{=}\mathrm{0}}, temos \ensuremath{\Varid{m}\;\Varid{x}\;\mathrm{0}\mathrel{=}\mathrm{8}\mathbin{*}\mathrm{0}\mathbin{+}\mathrm{22}\mathrel{=}\mathrm{22}}.

Portanto, podemos definir \ensuremath{\Varid{m}} como:

\begin{equation}
m \ x \ n =
     \begin{cases}
          22 & \text{se } n = 0\\
          m \ x \ n + 8 & \text{se } n > 0
     \end{cases}
\end{equation}

Tendo chegado a um ponto onde \ensuremath{\Varid{m}} é uma função linear simples, podemos agora expressar todas as funções
em termos de recursividade mútua.

\subsubsection*{Sistema final de recursividade mútua}

Reunindo todas as definições recursivas obtidas:

\begin{eqnarray*}
s \ x \ n &=& \begin{cases} 
          x & \text{se } n = 0\\
          s \ x \ (n-1) + \frac{h \ x \ (n-1)}{k \ x \ (n-1)} & \text{se } n > 0
     \end{cases}\\
h \ x \ n &=& \begin{cases}
          x^3 & \text{se } n = 1\\
          x^2 \cdot h \ x \ (n-1) & \text{se } n > 1
     \end{cases}\\
k \ x \ n &=& \begin{cases}
          6 & \text{se } n = 1\\
          k \ x \ (n-1) \cdot j \ x \ (n-1) & \text{se } n > 1
     \end{cases}\\
j \ x \ n &=& \begin{cases}
          20 & \text{se } n = 0\\
          j \ x \ (n-1) + m \ x \ (n-1) & \text{se } n > 0
     \end{cases}\\
m \ x \ n &=& \begin{cases}
          22 & \text{se } n = 0\\
          m \ x \ (n-1) + 8 & \text{se } n > 0
     \end{cases}
\end{eqnarray*}

Pela lei de recursividade mútua, este sistema pode ser expresso como:

\[
(s, h, k, j, m) = \text{for} \ (\text{loop} \ x) \ (\text{start} \ x)
\]

onde \ensuremath{\Varid{start}\;\Varid{x}} representa os valores iniciais e \ensuremath{\Varid{loop}\;\Varid{x}} representa a função de transição.

Para determinar \ensuremath{\Varid{start}\;\Varid{x}} e \ensuremath{\Varid{loop}\;\Varid{x}}, observemos que a função \ensuremath{\for{\cdot }\ {\cdot }} itera \ensuremath{\Varid{n}} vezes,
começando do estado inicial e aplicando repetidamente a função \ensuremath{\Varid{loop}}.

Os valores iniciais correspondem a \ensuremath{\Varid{n}\mathrel{=}\mathrm{0}}:
\begin{eqnarray*}
\text{start} \ x = (x, x^3, 6, 20, 22)
\end{eqnarray*}

A função \ensuremath{\Varid{loop}\;\Varid{x}} transforma o estado \ensuremath{(\Varid{s},\Varid{h},\Varid{k},\Varid{j},\Varid{m})} no próximo estado,
incrementando implicitamente \ensuremath{\Varid{n}}:

\begin{eqnarray*}
\text{loop} \ x \ (s, h, k, j, m) = (s + \frac{h}{k}, x^2 \cdot h, k \cdot j, j + m, m + 8)
\end{eqnarray*}

Finalmente, a função \ensuremath{\Varid{sinh}\;\Varid{x}\;\Varid{n}} corresponde à primeira componente do estado após \ensuremath{\Varid{n}} iterações:

\begin{eqnarray*}
\text{sinh} \ x \ n = \p1 \cdot \text{for} \ (\text{loop} \ x) \ (\text{start} \ x) \ n
\end{eqnarray*}

ou, usando \ensuremath{\Varid{head}} para extrair a primeira componente:

\begin{eqnarray*}
\text{sinh} \ x \ n = \text{head} \cdot \text{for} \ (\text{loop} \ x) \ (\text{start} \ x) \ n
\end{eqnarray*}

Esta é precisamente a estrutura da função \ensuremath{\Varid{f}\;\Varid{x}\;\Varid{n}} fornecida no enunciado, provando que
\ensuremath{\Varid{f}\;\Varid{x}\;\Varid{n}} calcula o seno hiperbólico de \ensuremath{\Varid{x}} com \ensuremath{\Varid{n}} aproximações da série de Taylor.

Transpondo para o código Haskell obtemos:

\begin{quote}
\begin{tabbing}\ttfamily
~sinh~\char58{}\char58{}~Floating~a~\char61{}\char62{}~a~\char45{}\char62{}~Int~\char45{}\char62{}~a\\
\ttfamily ~sinh~x~n~\char61{}~p1~\char46{}~for~\char40{}loop~x\char41{}~\char40{}start~x\char41{}~\char36{}~n\\
\ttfamily ~~~~~~where\\
\ttfamily ~~~~~~~~~~~start~x~\char61{}~\char40{}x\char44{}~x\char94{}3\char44{}~6\char44{}~20\char44{}~22\char41{}\\
\ttfamily ~~~~~~~~~~~loop~x~\char40{}s\char44{}~h\char44{}~k\char44{}~j\char44{}~m\char41{}~\char61{}\\
\ttfamily ~~~~~~~~~~~~~~~~\char40{}s~\char43{}~h~\char47{}~k\char44{}~x\char94{}2~\char42{}~h\char44{}~k~\char42{}~j\char44{}~j~\char43{}~m\char44{}~m~\char43{}~8\char41{}
\end{tabbing}
\end{quote}

Com pequenos ajustes, modificando os tuplos para listas e usando funções auxiliares,
obtemos a definição final de \ensuremath{\Varid{sinh}} igual à fornecida no enunciado.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{s}\mathbin{::}\Conid{Floating}\;\Varid{a}\Rightarrow \Varid{a}\to \Conid{Int}\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{s}\;\Varid{x}\;\Varid{n}\mathrel{=}\Varid{head}\comp \for{\Varid{loop}\;\Varid{x}}\ {\Varid{start}\;\Varid{x}}\mathbin{\$}\Varid{n}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\mathbf{where}{}\<[E]%
\\
\>[6]{}\hsindent{5}{}\<[11]%
\>[11]{}\Varid{start}\;\Varid{x}\mathrel{=}[\mskip1.5mu \Varid{x},\Varid{x}\mathbin{\uparrow}\mathrm{3},\mathrm{6},\mathrm{20},\mathrm{22}\mskip1.5mu]{}\<[E]%
\\
\>[6]{}\hsindent{5}{}\<[11]%
\>[11]{}\Varid{loop}\;\Varid{x}\;[\mskip1.5mu \Varid{s},\Varid{h},\Varid{k},\Varid{j},\Varid{m}\mskip1.5mu]\mathrel{=}[\mskip1.5mu \Varid{s}\mathbin{+}\Varid{h}\mathbin{/}\Varid{k},\Varid{x}\mathbin{\uparrow}\mathrm{2}\mathbin{*}\Varid{h},\Varid{k}\mathbin{*}\Varid{j},\Varid{j}\mathbin{+}\Varid{m},\Varid{m}\mathbin{+}\mathrm{8}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsection*{Problema 3}

\subsubsection*{Análise do problema}

O objetivo é fundir duas listas ordenadas em uma única lista ordenada,
de forma justa, ou seja, intercalando os elementos das duas listas
sempre que possível.

\subsubsection*{Derivação da lei dual da recursividade mútua}


Comece-se por provar a lei dual da recursividade mútua (de Fokkinga),
que nos permitirá definir a função \ensuremath{\Varid{fair\char95 merge'}} como um anamorfismo de listas.
Esta lei relaciona funções mutuamente recursivas com anamorfismos.

Sejam \ensuremath{\Varid{f}\mathbin{::}\Conid{A}\to \Conid{F}\;\mathit B} e \ensuremath{\Varid{g}\mathbin{::}\Conid{A}\to \Conid{F}\;\mathit C} duas funções mutuamente recursivas,
onde \ensuremath{\Conid{F}} é um functor, e \ensuremath{\alt{\Varid{f}}{\Varid{g}}\mathbin{::}\Conid{A}\to \Conid{F}\;(\mathit B+\mathit C)} a função que combina \ensuremath{\Varid{f}} e \ensuremath{\Varid{g}}.
Sejam \ensuremath{\Varid{h}\mathbin{::}\Conid{D}\to \mathit B} e \ensuremath{\Varid{k}\mathbin{::}\Conid{D}\to \mathit C} duas funções tais que:

\begin{equation}
\begin{aligned}
\ensuremath{\alt{\Varid{f}}{\Varid{g}}\mathrel{=}\ana{\alt{\Varid{h}}{\Varid{k}}}}
\end{aligned}
\end{equation}

Então, as seguintes equações são satisfeitas:

\begin{equation}
\begin{aligned}
\ensuremath{\alt{\Varid{f}}{\Varid{g}}\mathrel{=}\ana{\alt{\Varid{h}}{\Varid{k}}}}
&\equiv (universal \; property \; of \; ana)\\
\ensuremath{\Varid{out}\comp \alt{\Varid{f}}{\Varid{g}}\mathrel{=}\fun F \;\alt{\Varid{f}}{\Varid{g}}\comp \alt{\Varid{h}}{\Varid{k}}}
&\equiv (coproduct \; fusion \; x2)\\
\ensuremath{\alt{\Varid{out}\comp \Varid{f}}{\Varid{out}\comp \Varid{g}}\mathrel{=}\alt{\fun F \;\alt{\Varid{f}}{\Varid{g}}\comp \Varid{h}}{\fun F \;\alt{\Varid{f}}{\Varid{g}}\comp \Varid{k}}}
&\equiv (coproduct \; equals \; law)\\
\begin{cases}
\ensuremath{\Varid{out}\comp \Varid{f}\mathrel{=}\fun F \;\alt{\Varid{f}}{\Varid{g}}\comp \Varid{h}}\\
\ensuremath{\Varid{out}\comp \Varid{g}\mathrel{=}\fun F \;\alt{\Varid{f}}{\Varid{g}}\comp \Varid{k}}
\label{eq:fokkinga_dual1}
\end{cases}
\end{aligned}
\end{equation}

Provou-se, assim, a lei dual da recursividade mútua.

\subsubsection*{Aplicação da lei dual ao \textit{fair-merge}}

Considere-se o tipo de streams definido no enunciado:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Stream}\;\Varid{a}\mathrel{=}\Conid{Cons}\;(\Varid{a},\Conid{Stream}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

E o respetivo destrutor:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{out}\mathbin{::}\Conid{Stream}\;\Varid{a}\to (\Varid{a},\Conid{Stream}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{out}\;(\Conid{Cons}\;(\Varid{x},\Varid{xs}))\mathrel{=}(\Varid{x},\Varid{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

O functor associado a este tipo é, portanto:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{F}\;\Conid{S}\mathrel{=}\Conid{A}\times\Conid{S}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Isto representa que cada elemento de um stream é um par composto por um valor do tipo arbitrário \ensuremath{\Conid{A}}
(que representa o tipo dos elementos do stream) e o restante da estrutura do stream.

Pretende-se definir a função
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fair}\mathbin{\char92 \char95 }\Varid{merge}\mathbin{::}(\Conid{Stream}\lambda ,\Varid{a}\lambda \Varid{times}\;\Conid{Stream}\lambda ,\Varid{a})\mathbin{+}(\Conid{Stream}\lambda ,\Varid{a}\lambda \Varid{times}\;\Conid{Stream}\lambda ,\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{13}{}\<[13]%
\>[13]{}\lambda \Varid{to}\;\Conid{Stream}\lambda ,\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

como um anamorfismo.

Dada a definição mutuamente recursiva de \ensuremath{\Varid{fair\char95 merge}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fair\char95 merge}\mathrel{=}[\mskip1.5mu \Varid{h},\Varid{k}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{h}\;(\Conid{Cons}\;(\Varid{x},\Varid{xs}),\Varid{y})\mathrel{=}\Conid{Cons}\;(\Varid{x},\Varid{k}\;(\Varid{xs},\Varid{y})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{k}\;(\Varid{x},\Conid{Cons}\;(\Varid{y},\Varid{ys}))\mathrel{=}\Conid{Cons}\;(\Varid{y},\Varid{h}\;(\Varid{x},\Varid{ys})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Aplicando a lei dual da recursividade mútua, provada anteriormente
(equação~\ref{eq:fokkinga_dual1}), tem-se que:
\begin{equation}
\ensuremath{\alt{\Varid{h}}{\Varid{k}}\mathrel{=}\ana{\Varid{g}}}
\end{equation}

\
se, e só se, se verificarem as equações:
\[
\begin{cases}
out \cdot h = F[h,k] \cdot g_L \\
out \cdot k = F[h,k] \cdot g_R
\end{cases}
\]
onde $g = [g_L, g_R]$.

Como $F \; X = A \times X$, tem-se:
\[
F \; [h,k] = id \times [h,k]
\]

Assim, definem-se as componentes do gene do anamorfismo, $g$, da seguinte forma:
\[
\begin{aligned}
g_L(Cons(x,xs),y) &= (x,\; Right(xs,y)) \\
g_R(x,Cons(y,ys)) &= (y,\; Left(x,ys))
\end{aligned}
\]

Verifica-se então que:
\[
\begin{aligned}
out \cdot h (Cons(x,xs),y)
&= (x,\; k(xs,y)) \\
&= (id \times [h,k]) (x,\; Right(xs,y)) \\
&= F[h,k] \cdot g_L (Cons(x,xs),y)
\end{aligned}
\]

De forma análoga:
\[
\begin{aligned}
out \cdot k (x,Cons(y,ys))
&= (y,\; h(x,ys)) \\
&= (id \times [h,k]) (y,\; Left(x,ys)) \\
&= F[h,k] \cdot g_R (x,Cons(y,ys))
\end{aligned}
\]

Logo, ambas as equações da lei dual são satisfeitas.

\subsubsection*{Síntese: Transformação em anamorfismo}

Tendo provado que o gene satisfaz as equações da lei dual de Fokkinga 
(equações acima), pela propriedade universal do anamorfismo, 
podemos agora expressar \ensuremath{\Varid{fair\char95 merge}} diretamente como: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fair\char95 merge'}\mathrel{=}\lanabracket\,\Varid{g}\,\ranabracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

onde \ensuremath{\Varid{g}\mathrel{=}\alt{\Varid{g\char95 L}}{\Varid{g\char95 R}}} com as componentes já derivadas anteriormente.
Escrevendo \ensuremath{\Varid{g}} de forma explícita e única, obtem-se a definição final do gene
com:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{g}\mathbin{::}(\Conid{Stream}\;\Varid{a},\Conid{Stream}\;\Varid{a})+(\Conid{Stream}\;\Varid{a},\Conid{Stream}\;\Varid{a})\to (\Varid{a},(\Conid{Stream}\;\Varid{a},\Conid{Stream}\;\Varid{a})+(\Conid{Stream}\;\Varid{a},\Conid{Stream}\;\Varid{a})){}\<[E]%
\\
\>[B]{}\Varid{g}\;(i_1\;{}\<[10]%
\>[10]{}(\Conid{Cons}\;(\Varid{x},\Varid{xs}),\Varid{y}))\mathrel{=}(\Varid{x},i_2\;(\Varid{xs},\Varid{y})){}\<[E]%
\\
\>[B]{}\Varid{g}\;(i_2\;(\Varid{x},\Conid{Cons}\;(\Varid{y},\Varid{ys})))\mathrel{=}(\Varid{y},i_1\;(\Varid{x},\Varid{ys})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A definição obtida caracteriza \textit{fair\_merge} como um processo
iterativo infinito, no qual cada passo:
(i) seleciona o próximo elemento de uma das streams,
(ii) alterna a stream ativa,
e (iii) continua o processo a partir do novo par de streams.

Esta abordagem evita a utilização de recursão explícita,
tornando evidente o caráter justo da fusão das duas streams.

\subsection*{Problema 4}

Queremos descobrir a probabilidade da frase que abaixo se apresenta ser gerada por um processo probabilístico que pode parar a qualquer momento, emitindo a palavra "stop", ou continuar a emitir palavras da frase original com alta probabilidade.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{frase}\mathrel{=}[\mskip1.5mu \text{\ttfamily \char34 Vamos\char34},\text{\ttfamily \char34 atacar\char34},\text{\ttfamily \char34 hoje\char34}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Para modelar este processo, utilizamos o mónade de distribuições de probabilidade Dist, que nos permite representar escolhas probabilísticas de forma elegante.

Define-se, primeiramente, um catamorfismo probabilístco, pcataList, que processa a lista de palavras e aplica uma função gene, g, que determina as probabilidades de parar ou continuar a geração da frase.
Este usa a notação \ensuremath{\mathbf{do}}, que facilita a manipulação de ações monádicas.
Na sua essência, a operação executada por pcataList, descreve-se como:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pcataList}\;\Varid{g}\;[\mskip1.5mu \mskip1.5mu]{}\<[20]%
\>[20]{}\mathrel{=}\Varid{g}\;(i_1\;()){}\<[E]%
\\
\>[B]{}\Varid{pcataList}\;\Varid{g}\;(\Varid{x}\mathbin{:}\Varid{xs})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{y}\leftarrow \Varid{pcataList}\;\Varid{g}\;\Varid{xs};\Varid{g}\;(i_2\;(\Varid{x},\Varid{y}))\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection*{Interpretação probabilística e origem de \texttt{pcataList}}

Seja \texttt{M} um mónade, com operações \texttt{return} e
\texttt{>>=} (bind).
Define-se o \emph{operador monádico} (também designado por composição de
Kleisli) por:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f}\kcomp \Varid{g}\mathrel{=}\lambda \Varid{x}\to \Varid{g}\;\Varid{x}\bind \Varid{f}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Este operador permite compor funções que produzem efeitos monádicos,
encadeando corretamente esses efeitos.

No caso do mónade das distribuições de probabilidade \texttt{Dist},
o operador $\bullet$ corresponde à combinação sequencial de escolhas
aleatórias, propagando as probabilidades dos resultados.

\medskip

Considere-se agora a definição recursiva de \texttt{pcataList}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pcataList}\;\Varid{g}\;(\Varid{x}\mathbin{:}\Varid{xs})\mathrel{=}\Varid{pcataList}\;\Varid{g}\;\Varid{xs}\bind (\lambda \Varid{y}\to \Varid{g}\;(i_2\;(\Varid{x},\Varid{y}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Usando a definição do operador monádico, esta expressão pode ser
reescrita como:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pcataList}\;\Varid{g}\;(\Varid{x}\mathbin{:}\Varid{xs})\mathrel{=}\lambda \Varid{y}\to \Varid{g}\;(i_2\;(\Varid{x},\Varid{y}))\kcomp \Varid{pcataList}\;\Varid{g}\;\Varid{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Esta forma mostra que \texttt{pcataList} é construída exclusivamente
através de composições monádicas, sem recorrer a recursão explícita
sobre efeitos.

\subsubsection*{Origem da definição de \texttt{pcataList}}

A função \texttt{pcataList} processa uma lista da direita para a
esquerda, combinando os efeitos monádicos produzidos pelo gene $g$.

O gene:
\[
g :: Either () (a,b) \to Dist\,b
\]
descreve o comportamento local do processo:
\begin{itemize}
  \item quando recebe \texttt{Left ()}, decide probabilisticamente se o
        processo termina imediatamente;
  \item quando recebe \texttt{Right (x,y)}, decide se o processo
        continua, incorporando a palavra $x$, ou se termina nesse ponto.
\end{itemize}

Em cada passo, o resultado probabilístico da cauda da lista é combinado
com o efeito descrito por $g$ usando o operador monádico $\bullet$.
Este encadeamento garante que todas as probabilidades são corretamente
propagadas.

\subsubsection*{Interpretação probabilística}

A expressão:
\[
(\lambda y \to g(\mathrm{Right}(x,y))) \bullet pcataList\ g\ xs
\]
significa que:
\begin{enumerate}
  \item primeiro se gera, de forma probabilística, o resultado associado
        à cauda da lista;
  \item para cada resultado possível, se aplica o gene $g$;
  \item as distribuições resultantes são combinadas segundo as leis da
        Mónade \texttt{Dist}.
\end{enumerate}

Assim, \texttt{pcataList} modela um processo probabilístico que pode
interromper a geração da frase a qualquer momento, mas que respeita a
estrutura da lista e a semântica dos mónades.

\subsubsection*{Construção do gene a partir de distribuições explícitas}

A função gene descreve o comportamento local do processo
probabilístico responsável pela geração da frase.
Em cada passo, o processo pode parar ou continuar, de acordo com
probabilidades previamente definidas.

O tipo de gene é:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{gene}\mathbin{::}()+(\Conid{String},[\mskip1.5mu \Conid{String}\mskip1.5mu])\to \fun{Dist}\;[\mskip1.5mu \Conid{String}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Para justificar a sua definição, começa-se por descrever explicitamente
as distribuições de probabilidade pretendidas em cada caso.

\subsubsection*{Caso base: distribuição explícita}

No caso base, correspondente ao valor \texttt{Left ()}, pretende-se
modelar a possibilidade de o processo terminar imediatamente.

Define-se a distribuição de probabilidade pretendida como:
\[
\begin{array}{c\textbar c}
\text{Resultado} & \text{Probabilidade} \\ \hline
["stop"] & 0.9 \\
[] & 0.1
\end{array}
\]



Esta distribuição indica que, com elevada probabilidade, o processo
termina e emite a palavra \texttt{"stop"}, mas que existe ainda uma
pequena probabilidade de não emitir nenhuma palavra.

Em termos da Mónade \texttt{Dist}, esta distribuição poderia ser
representada explicitamente como:
\[
[(0.9, ["stop"]), (0.1, [])]
\]

No entanto, para maior clareza e concisão, esta distribuição é
encapsulada através do combinador:
\[
choose\ p\ x\ y
\]
que representa uma escolha probabilística entre os valores $x$ e $y$,
com probabilidade $p$ e $1-p$, respetivamente.

Assim, a distribuição anterior pode ser escrita como:
\[
g_1() = choose\ 0.9\ ["stop"]\ []
\]

\subsubsection*{Caso recursivo: distribuição explícita}

No caso recursivo, correspondente ao valor \texttt{Right (w,rest)},
pretende-se decidir se a palavra atual \texttt{w} é incluída na frase
gerada ou se o processo termina nesse ponto.

A distribuição desejada é:
\[
\begin{array}{c\textbar c}
\text{Resultado} & \text{Probabilidade} \\ \hline
w:rest & 0.95 \\
rest & 0.05
\end{array}
\]

Esta distribuição traduz a ideia de que o processo tende a continuar,
mas pode parar com pequena probabilidade.

De forma explícita, esta distribuição seria:
\[
[(0.95, w:rest), (0.05, rest)]
\]

Tal como no caso base, esta distribuição é posteriormente expressa de
forma mais compacta usando o combinador \texttt{choose}:
\[
g_2(w,rest) = choose\ 0.95\ (w:rest)\ rest
\]

\subsubsection*{Definição final do gene}

Tendo definido separadamente os comportamentos probabilísticos dos dois
casos, estes são combinados utilizando a função \texttt{either},
obtendo-se a definição final de gene:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{gene}\mathbin{::}()+(\Conid{String},[\mskip1.5mu \Conid{String}\mskip1.5mu])\to \fun{Dist}\;[\mskip1.5mu \Conid{String}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{gene}\mathrel{=}\alt{\Varid{g1}}{\Varid{g2}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mbox{\onelinecomment  Caso Base: Parar a geração com a palavra 'stop'}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{g1}\;()\mathrel{=}\Varid{choose}\;\mathrm{0.9}\;[\mskip1.5mu \text{\ttfamily \char34 stop\char34}\mskip1.5mu]\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{g2}\;(\Varid{w},\Varid{rest})\mathrel{=}\Varid{choose}\;\mathrm{0.95}\;(\Varid{w}\mathbin{:}\Varid{rest})\;\Varid{rest}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection*{Cálculo da probabilidade da frase}

Aplicando o gene definido anteriormente à frase
e usando a definição de \texttt{transmitir} do enunciado, obtém-se:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{resultado}\mathrel{=}\Varid{transmitir}\;\Varid{frase}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A variável \texttt{resultado} conterá a distribuição de probabilidade
associada a todas as frases possíveis geradas pelo processo.

Correndo o código, obtém-se as probabilidades associadas a cada frase:

\begin{center}
\begin{tabular}{r|r}
\texttt{["Vamos","atacar","hoje","stop"]} & $77.2\%$ \\
\texttt{["Vamos","atacar","hoje"]} & $8.6\%$ \\
\texttt{["Vamos","atacar","stop"]} & $4.1\%$ \\
\texttt{["Vamos","hoje","stop"]} & $4.1\%$ \\
\texttt{["atacar","hoje","stop"]} & $4.1\%$ \\
\texttt{["Vamos","atacar"]} & $0.5\%$ \\
\texttt{["Vamos","hoje"]} & $0.5\%$ \\
\texttt{["atacar","hoje"]} & $0.5\%$ \\
\texttt{["Vamos","stop"]} & $0.2\%$ \\
\texttt{["atacar","stop"]} & $0.2\%$ \\
\texttt{["hoje","stop"]} & $0.2\%$ \\
\texttt{["atacar"]} & $0.0\%$ \\
\texttt{["hoje"]} & $0.0\%$ \\
\texttt{["Vamos"]} & $0.0\%$ \\
\texttt{["stop"]} & $0.0\%$ \\
\texttt{[]} & $0.0\%$ \\
\end{tabular}
\end{center}

Portanto, respondendo às questões iniciais:
\begin{itemize}
\item A probabilidade de a palavra \texttt{"atacar"} se perder é de $\mathbf{4.1\%}$
\item A probabilidade de seguirem todas as palavras, mas faltar o \texttt{"stop"} é de $\mathbf{8.6\%}$
\item A probabilidade de transmissão perfeita é de $\mathbf{77.2\%}$
\end{itemize}

%----------------- Índice remissivo (exige makeindex) -------------------------%

\printindex

%----------------- Bibliografia (exige bibtex) --------------------------------%

\bibliographystyle{plain}
\bibliography{cp2526t}

%----------------- Fim do documento -------------------------------------------%
\end{document}
